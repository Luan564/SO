a.asm -> contendra instrucciones (SerÃ¡n los procesos que ejecute nuestro sistema operativo)

    instruccion 1
    instruccion 2
    ...
    instruccion n

   Ejemplos de instrucciones:
        MOV -> AsignaciÃ³n
        ADD -> Suma
        SUB -> Resta
        MUL -> MultiplicaciÃ³n
        DIV -> DivisiÃ³n
        INC -> Incremento
        DEC -> Decremento

Asi se verÃ¡ el archivo de instruccione que leera el programa:
    MOV Ax, 5       //Ax=5
    ADD Bx, 7       //Bx=Bx+7
    SUB Cx, 4       //Cx=Cx-4
    MUL Dx, 2       //Dx=Dx*4
    DIV Ax, 2       //Ax=Ax/2
    INC Bx          //Bx=Bx+1
    DEC Cx          //Cx=Cx-1





Interprete: Leera todo el comando por ejemplo "> ejecuta a.asm", "> salir"


Comprobar que se escribe la cadena "ejecuta" y posterior a ello analizar la segunda cadena "a.asm" por ejemplo
en caso de no existir se imprimira un mensaje de ERROR, pero en caso de si existir imprimir las operaciones que
se van realizando 

en terminar imprimir id, Ax, Bx, Cx, Dx, el valor de Pc y el valor de Ir.






#include<stdio.h>
#include<string.h>

int main(){
    char cadena[50]= "Esto es una prueba";
    char copia[50];
    char *delimitador=" ";
    char *token;
        strcpy(copia,cadena);
        //printf("Cadena original:\n",cadena);
        token = strtok(cadena,delimitador);
        //printf("Mi token %s\n",token);
        //printf("Cadena despues del strtok %s\n",cadena);

        while (token !=NULL){
            printf("Token: %s\n",token);
            token=strtok(NULL,delimitador);
        }
        
return 1;
}

principal.c 
    - controlador.c
        - interprete.c
            - comando.c                 //extraerComando, limpiarBuffer âœ…âœ…
            - controlador_procesos.c      //crearPr, insertarPr, moverPr, desligarPr, recorrerLista, imprimirPr, eliminarPr 
                -leer_proceso.c         //leerProceso âœ…
                    - instrucciones.c           //analizadorGpo1, analizadorGpo2 âœ…âœ…
                        - validar.c             //validarRegistro, tipoOperacion, esNumeroValido, obtenerRegistro âœ…âœ…âœ…âœ…
                        - alu.c                 //aluGpo1, aluGpo2 âœ…
    
    ejecuta a.asm b.asm c.asm

//Re-estructuraciÃ³n


Para las estructuras crear un nuevo .h
1.- Crear estructura para los registros (Ax, Bx, Cx, Dx, PC, Ir, Proceso)
2.- Crear estructura para el buffer (ejecuta a.asm)         //âœ…
5.- Crear estructura para los estados   
6.- Crear estructura para las operaciones

Crear nuevos archivos .c: comando.c, controlador_procesos.c, instrucciones.c //??????
3.- Funcion interprete actualmente: Analiza el buffer, abre el archivo, ejecuta las instrucciones del archivo 
    Separar responsabilidades de Controlador[interprete.c {comando.c, controlador_procesos.c, instrucciones.c}]

4.- principal.c menor cantidad de lineas posibles
7.- Crear nuevo archivo para INICIALIZAR TODO ðŸ˜‰

// ImplementaciÃ³n de ncurses
# Funciones bÃ¡sicas de ncurses a utilizar:
initscr();            // Inicializa la pantalla
mvprintw(y, x, "Texto"); // Mueve el cursor a la posiciÃ³n (y, x) y imprime "Texto"
refresh();           // Actualiza la pantalla para reflejar los cambios realizados
endwin();            // Finaliza el modo ncurses y restaura la terminal a su estado original

## Funciones que podrÃ­an ser Ãºtiles:
cbreak();            // Desactiva el buffer de lÃ­nea, permitiendo la entrada de caracteres uno por uno.
noecho();            // Desactiva la visualizaciÃ³n de los caracteres ingresados por el usuario
keypad(stdscr, TRUE); // Habilita la captura de teclas especiales (como las flechas) en la ventana estÃ¡ndar.
clear();             // Limpia la pantalla
getstr(str);      // Lee una cadena de caracteres desde la entrada estÃ¡ndar (similar a scanf, pero mÃ¡s seguro)
usleep(100);;            // Lee un solo carÃ¡cter desde la entrada estÃ¡ndar

# Variables de ncurses
WINDOW *win;          // Puntero a una ventana de ncurses que se pasa a initscr() para inicializar la pantalla.

Estrategia de implementaciÃ³n:
Usar variable apuntador window *window de modo "extern"



Entrega Dois:

1.- Agregar comando END (FACILLL)   //âœ…
2.- Crear estructuta PCB (Process control block)
    -Id, Pc, Ax, Bx, Cx, Dx, Ir, Estado, Nombre(tipo char nombre del archivo), *FILE archivo, *PCB siguiente
3.- Agregar Funciones de Listas 
    -Crear, insertar, desligar, mover entre listas, recorrer lista, eliminar[al mero final]
4.- Impresiones mamalonas con ncurses
5.- Solo leer archivos con extencion .asm       //âœ…





//controlador_procesos.c  Funcion que quita los espacios en blanco de "MOV Ax , 7"
int i = 0, j = 0;
        strtok(NULL, "#"); Ax  ,  7
        while(operandos[i] != '\0'){
            if(operandos[i] != ' '){
                aux1[j] = operandos[i];     Ax,7'\0'
                j++;
            }
            i++;
        }
        aux1[j] = '\0';
        // printf("ope: %s, aux: %s\n",operandos, aux1);
        strcpy(operandos,aux1);
        
        
        //strcpy(operandos, aux1);


// en interprete.c Funcion END del examen.
if (strcmp("END", token) == 0){
    bandera = 1;
    imprimirFilaConError("Instruccion END encontrada, cierre del documento");
    fclose(archivo);
    reg_pc++;
    return 0;
}


// comando.c    Funcion que solo acepta cadenas archivos *.asm
	if(strcmp(bufferC->argumento,strtok(token, ".")) == 0){     //a.asm
	    imprimirError("Falta especificar extension");
	    return -1;
	}
	extension = strtok(NULL,".");	//asm
	if(extension == NULL){
	    imprimirError("Falta especificar extension");
	    return -1;
	}
	if(strcmp("asm", extension) != 0){
	    imprimirError("Extension invalida");
	    return -1;
	}
        strcpy(reg_ir, "");
        strcpy(reg_proceso, bufferC->argumento);

		






